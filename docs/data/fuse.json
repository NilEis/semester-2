{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title"},{"path":["body"],"id":"body","weight":1,"src":"body"}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"2. Semester","n":0.707},"1":{"v":"\n# 2. Semester\n## Module\n- [[Datenstrukturen und Algorithmen|DSAL]]\n- [[Formale Systeme, Automaten und Prozesse|FOSAP]]\n- [[Betriebssysteme und Systemsoftware|BUS]]","n":0.258}}},{"i":2,"$":{"0":{"v":"Formale Systeme, Automaten und Prozesse","n":0.447},"1":{"v":"\n# Formale Systeme, Automaten und Prozesse\n1. [[Überblick|FOSAP.ueberblick]]\n2. [[Deterministische Endliche Automaten|FOSAP.DEA]]\n","n":0.316}}},{"i":3,"$":{"0":{"v":"Überblick","n":1},"1":{"v":"\n# Formale Systeme und Modelle\n- Beschreibung von:\n  - Programmiersprachen\n  - Spezifikationen (UML)\n  - Daten und deren Beziehungen\n  - Netzwerken\n  - Modellierung von Rechnern und Berechnungen\n  - Komplexen Systemen\n\n## Zentrale Fragen\n- Wie kann man ein formales System spezifizieren? (Syntax)\n- Wie kann man den formalen Objekten eine klar definierte Bedeutung geben? (Semantik)\n- Wie kann man die Eigenschaften eines formalen Systems verstehen?\n- Wie kann man (auch algorithmisch) mit einem formalen System arbeiten?\n\n## Automaten\n- Endliche Automaten und Verallgemeinerungen von Kellerautomaten -> Turingmaschinen\n\n## Grammatiken\n- RegEx und kontextfreie Grammatiken\n\n## Nebenläufige Systene\n- Petrinetze und Prozesskalküle\n\n## Mathematische Methoden\n- exakte Definitionen\n- formale Beweise\n- Verwendung mathematischer Strukturen wie Graphen\n\n## Korrektheit\n- Grundlagen formaler Verifikationsmethoden\n\n## Automatisierung\n- formale Beschreibungen der Anforderungen\n","n":0.096}}},{"i":4,"$":{"0":{"v":"Deterministische Endliche Automaten","n":0.577},"1":{"v":"\n# Deterministische Endliche Automaten\n## Endliche Automaten\n- Berechnungsmodell zur Beschreibung sequentiller Prozesse\n- endliche Menge an Zuständen\n- Hat einen Startzustand und 1 oder mehr Endzustände\n\n### Mustererkennung\n```mermaid\ngraph LR\nn((nichts)) -->|0|n((nichts))\nn((nichts)) -->|1|1((1))\n1((1))-->|0|n((nichts))\n1((1))-->|1|11((11))-->|1|11((11))\n11((11))-->|0|110((110))\n110((110))-->|0|n((nichts))\n110((110))-->|1|1101((1101))-->|0,1|1101((1101))\n```\n### Teilbarkeit durch 3\n```mermaid\ngraph LR\n0((0))\n1((1))\n2((2))\n0-->|1,4,7|1\n1-->|2,5,8|0\n1-->|1,4,7|2\n2-->|2,5,8|1\n2-->|1,4,7|0\n0-->|2,5,8|2\n0-->|0,3,6,9|0\n1-->|0,3,6,9|1\n2-->|0,3,6,9|2\n```\n## Alphabet\n- Nicht leere Menge\n  - behinhaltet Symbole,Buchstaben oder Zeichen\n- Ein Wort ist eine endliche Folge von Zeichen aus dem Alphabet\n\n### Notation\n- $\\sum$,$\\Gamma$ und Varianten wie $\\sum_1$, $\\Gamma'$\n- $a,b,c,\\dotsc$ und Varianten stehen für Zeichen\n\n### Beispiele\n1. Boolsche Alphabet $\\{0,1\\}$\n2. Morsealphabet $\\{.,-,\\quad\\}$\n\n## Wörter\n### Notation\n- Ohne Klammern und Kommata\n- $u,v,w,\\dotsc$ und Varianten stehen für Wörter\n\n## Sprache\n- Menge von Wörtern\n\n# DEA\n- 5-Tupel $(Q,\\sum,\\delta,q_0,F)$\n  - $Q$: Menge der Zustände\n  - $\\sum$: Eingabealphabet\n  - $\\delta: Q \\times \\sum \\rightarrow Q$: Abbildung: die Transitionsfunktionen\n  - $q_0 \\in Q$: Der Anfangszustand\n  - $F \\subseteq Q$: Die Menge der Endzustände\n\n","n":0.091}}},{"i":5,"$":{"0":{"v":"Datenstrukturen und Algorithmen","n":0.577},"1":{"v":"\n# Datenstrukturen und Algorithmen\n1. [[Überblick|DSAL.ueberblick]]\n2. Datenstrukturen\n   1. [[DSAL.abstraktedatenstrukturen]]\n   2. [[DSAL.linearedatenstrukturen]]\n","n":0.316}}},{"i":6,"$":{"0":{"v":"Überblick","n":1},"1":{"v":"\n# Überblick\n- Software = Datenstrukturen + Algorithmen\n- Schrittweise Modifikation von Daten zur Lösung von Problemen\n- Eigenschaften (nach Donald Knuth)\n  - Determinismus\n  - Input ($\\# \\geq 0$)\n  - output ($\\# \\geq 0$)\n  - Terminierung\n\n# Analyse\n- partielle Korrektheit\n- totale Korrektheit\n- Komplexität\n  - Speicherplatz\n  - Rechenzeit\n- Robustheit\n  - bei korrekter Eingabe\n\n# Komplexität\n- Effizienz (Praxistauglichkeit)\n- worst/best/average case\n- Wie viel länger dauert die Berechnung, wenn der Input verdoppelt wird\n- Gibt es einen besseren Algorithmus (Problem-Reduktion)\n\n# Effizienz\n- Problem $\\rightarrow$ Ressourcen\n- Ressourcen $\\rightarrow$ Problem\n- Ressourcen-Typen\n  - Rechenzeit\n  - Speicherplatz\n  - Energieverbrauch\n  - ...\n","n":0.108}}},{"i":7,"$":{"0":{"v":"Lineare Datenstrukturen","n":0.707},"1":{"v":"\n# Lineare Datenstrukturen\n- Sequenz $\\{x_1,\\dotsc,x_n\\}$\n\n## Listen\n- $L = \\{x_1,\\dotsc,x_n\\}$\n- Zugriff auf beliebige Elemente $x_i$\n  - Per Index\n    - `Get(i)`\n  - Per Marker\n    - `GetFirst()`\n    - `GetNext()`\n    - `GetPrevious()`\n- Random Access\n  - Implementierung durch Arrays\n  - `Get(i) = L[i]`\n  - Nachteile\n    - Elemente Löschen erzeugt Lücken, oder alle höheren Elemnte müssen verschoben werden\n    - statische Obergrenze für Listenlänge\n- Sequential Access\n  - Implementierung durch Pointer oder Container\n  - Marker zeigt auf aktuelle Position\n  - Nachteil:\n    - Elementzugriff erfordert lineare Suche\n  - Beliebiges Erweitern oder Löschen\n\n","n":0.11}}},{"i":8,"$":{"0":{"v":"Abstrakte Datenstrukturen","n":0.707},"1":{"v":"\n# Abstrakte Datenstrukturen\n- Keine Festlegung der Implementierung\n- Axiome beschreiben statische Beziehungen\n- Beispiele\n  - Aufzählungstypen (`bool`, `enum`)\n  - Skalare Typen (`char`, `int`, `float`, ...)\n    - Eindimensionaler Wertebereich\n    - In Praxis meist endlich \n  - Zusammengesetzte Typen (`struct`, `class`)\n  - Lineare Strukturen (`list`, `queue`, `stack`)\n  - Bäume\n  - Graphen\n- endlicher Wertebereich\n  - vollständig durch Tabellen spezifizierbar\n- Verallgemeinerung\n  - Aufzählungstypen: `enum`\n  - z.B. Wochentage, chemische Elemente\n  - Kodierung (oft) als ganze Zahl Modulo n (implizite Ordnungsrelation)\n\n## Natürliche Zahlen\n\n```py\ndef ZERO():\n    return []\n\ndef SUCC(x):\n    return x + [1]\n\ndef PRED(x):\n    return x[1:]\n\ndef VALUE(x):\n    return len(x)\n\ndef ADD(x, y):\n    if x == ZERO():\n        return y\n    return SUCC(ADD(PRED(X),y))\n\ndef MUL(x, y):\n    if x == ZERO():\n        return ZERO()\n    return ADD(MUL(PRED(x), y), y)\n```\n","n":0.095}}},{"i":9,"$":{"0":{"v":"Betriebssysteme und Systemsoftware","n":0.577},"1":{"v":"\n# Betriebssysteme und Systemsoftware\n1. [[BUS.OS_aufbau_und_aufgaben]]","n":0.447}}},{"i":10,"$":{"0":{"v":"Betriebssysteme: Aufbau und Aufgaben","n":0.5},"1":{"v":"\n# Aufbau und Aufgaben\n## Einteilung des Computers in vier Bereiche\n1. Computer Hardware: Ansammlung von Betriebsmitteln, welche die Ausführung von Programmen ermöglichen\n2. Betriebssystem: Verwaltung und Koordination der Hardware\n3. System- und Anwendungsprogramme\n4. Benutzer: Menschen oder andere Computer\n\n## Computer-Hardware\n- Systembus verbindet alle Geräte des Computers\n   - Eine oder mehrere CPUs\n   - Gemeinsamer Speicher für Aufgaben der CPU und anderer Geräte\n   - Controller zum Anschluss von I/O-Geräten\n- von-Neumann: Prominente Rechnerarchitektur\n\n```mermaid\ngraph TD\nCPU[CPU]-->Systembus\nFestplatten[Festplatten]-->Fest[Festplatten Controller]-->Systembus\nDrucker[Drucker]-->usb[USB Controller]\nMaus[Maus]-->usb[USB Controller]\nTastatur[Tastatur]-->usb[USB Controller]\nExterne[Externe Laufwerke]-->usb[USB Controller]\nusb[usb]-->Systembus\nMonitor[Monitor]-->Grafikkarte\nGrafikkarte[Grafikkarte]-->Systembus\nSystembus-->Hauptspeicher\n```\n## CPU\n- Verfügt über Register zur Ausführen von Operationen\n  - Datenregister, Adressregister, Spezialregister\n- Zusätzlich: Caches\n  - Schneller Pufferspeicher\n  - Schnellerer Zugriff auf Caches als als auf Hauptspeicher\n  - Je kleiner, desto schneller\n  - Caches sind transparent für das Betriebssystem\n\n### Pipelining\n-  Das Ausführen der einer Instruktion lässt sich in Unterinstruktionen aufteilen\n   -  Fetch->Decode-Execute\n- Dadurch lässt sich Instruktionsparallelismus implementieren\n- Vorteil\n  - Höherer Durchsatz\n- Nachteil\n  - Teilweise höhere Latenz\n\n### Superskalare Ausführung\n- Wenn mehr Ausführungseinheiten existieren, können mehrere Instruktionen parallel ausgeführt werden\n\n## Zusammenspiel der Komponenten\n- CPU führt Operationen aus\n- CPU und I/O-Geräte werden nebenläufig ausgeführt\n  - Jeder Controller ist für einen bestimmten Gerätetyp verantwortlich\n  - Zur Ausführung einer Operation eines Gerätes wird die CPU gebraucht\n    - Jeder Controller hat eigene Register und einen lokalen Buffer\n    - Die CPU verschiebt Daten zwischen Hauptspeicher und Caches\n    - Nach verschieben der Daten wird die Operation gestartet\n  - Heute: DMA - Direct Memory Access\n    - Separater Controller zum verschieben von Daten zwischen CPU und Geräten\n    - Entlastung der CPU\n\n# Betriebssystem:\n- Ansammlung von Programmen zur effizienten und komfortablen Nutzung\n  - Plattform zur Ausführung von Programmen\n  - Effiziente Aufteilung der _Betriebsmittel_ (CPU, Festplatten, ...) auf mehrere Benutzer bzw. Benutzerprogramme\n- Betriebsmittel:\n  - Prozessoren, Prozesse, Threads\n  - Speicher\n    - Hauptspeicher, Caches, virtueller Speicher\n  - Dateisystem\n    - Verzeichnisse, Dateien\n  - I/O-Geräte\n    - Grafikkarte, Netzwerkkarte, Festplatte, Tastatur, Maus\n  - Klassifikation\n    - Exklusive oder geteilte Nutzung?\n    - Entziehbar oder nicht entziehbar?\n    - ","n":0.058}}}]}
