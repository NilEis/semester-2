{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"2. Semester","n":0.707},"1":{"v":"\n[![Build Dendron Static Site](https://github.com/NilEis/semester-2/actions/workflows/publish.yml/badge.svg)](https://github.com/NilEis/semester-2/actions/workflows/publish.yml)\n\n## Module\n- [[Betriebssysteme und Systemsoftware|BUS]]\n- [[Datenstrukturen und Algorithmen|DSAL]]\n- [[Formale Systeme, Automaten und Prozesse|FOSAP]]\n- [[Lineare Algebra|LA]]\n- [[Proseminar|PS]]\n- [[Dictionary|dict]]","n":0.224}}},{"i":2,"$":{"0":{"v":"Dictionary","n":1},"1":{"v":"\n# Among Us\n- Among Us, Amogus, Mogus, Asmolgus, Abominatiogus, Abacus \n- Sus, sussy, suspicious, suspekt, verd√§chtig\n- Sie sind unter uns üò≥\n- Impostor, Hochstapler, Verr√§ter\n- amongussy\n- Jerma Sus, JeSUS, ASUS\n- ‡∂û\n\n# Names\n- Quandale Dingle\n- Daquavious Bingleton\n- Jollywap McFunkerdoodlesnickerbottom\n\n# Morbius\n- Morbius\n- get morbed, it's morbin' time, I'm about to morb\n\n# Meme\n- I forgor üíÄ\n- I rember üòÅ\n- Literally 1984\n- Touch Grass\n- Heheheha, Hog Rideeer\n\n# German\n- Br√ºh, Br√ºh Moment, Br√ºhsuppe, wenn die Suppe br√ºht\n- Gamer Moment, Epischer Gamer Moment, Epischer Sieg, zertifizierten Gamer Moment\n- Wir sind nicht gleich\n- Habakuk\n- Protojockel, Oberjochen\n- Ei karamber, heilige Gwackermoli\n- Ford Focus, Fogus, Foggus, Fuggus\n- Framstag bei Penny\n- Minjens\n- Kika Tanzalarm, Kikaninchen, Dibedibedab, Und hop\n- Fahrschulapp, Ich halte das Lenkrad gerade und fest\n- Gommemode \n- Herr Anwalt\n- Daumen (Daviid)","n":0.091}}},{"i":3,"$":{"0":{"v":"Proseminar Image Processing","n":0.577},"1":{"v":"\n# Scientific work\n## Seminar report\n### General Guidelines\n- Lesen und **verstehen**\n  - Nicht nur √ºbersetzen\n  - In eigenen Worten schreiben\n  - *Keine Inhaltsangabe / √úbersetzung*\n- Nach weiteren Quellen suchen\n  - Mehr Inhalt\n- Thema im Detail erkl√§ren k√∂nnen\n- Bilder und Tabellen\n  - √úberschriften\n  - Bezug zu Text\n  - Quellen angeben\n- $\\LaTeX$\n  - BibTeX\n\n----------------\n### Scientific citations\n- Immer in Anf√ºhrungszeichen und mit Quelle\n- Bilder nur mit Quelle\n- Bei Bezug zu anderen *Ideen* Quellen angeben\n- \"~~We propose~~\"\n- Direkte Zitate vermeiden\n- Gute Quellen\n  - Scientific articles\n    - Struktur\n      - Autor\n      - Abstrakt\n      - Einleitung\n      - Bezug zu √§hnlichen Arbeiten\n      - Beschreibung der Methoden\n      - Experiment\n      - *Conclusion*\n      - Referenzen\n        - **Nicht ignorieren**$^{(\\text{best})}$\n  - conference papers\n  - B√ºcher\n  - $\\Rightarrow$ RWTH-Netz\n- Schlechte Quellen\n  - Wikipedia\n  - Weblogs\n  - H√∂rensagen\n- ???\n  - ArXiv $\\rightarrow$ Vorsicht\n- Originalquellen\n- Einheitliches Zitieren\n  - Konferenz\n    - Titel, Autor, Konferenz, Jahr\n  - Artikel\n    - Titel, Author, Journal, Ausgaben, Nummer, Seite, Jahr, Herausgeber\n  - B√ºcher\n    - Titel, Autor, Herausgeber, Jahr\n  - Webseiten\n    - Link, Autor, Jahr\n- Standard: $\\rightarrow$ BibTeX\n- \"Was will man eigentlich machen\"\n- Abgaben online\n\n----------------\n### Presentation\n- Types of presentations\n  - Overview\n    - Report\n      - Conference talk\n      - 30 Minuten\n        - Interview\n          - Lecture\n            - PhD defense\n              - Tutorial\n  - Context $\\rightarrow$ Proseminar Image Processing\n  - Maximaldauer: 15-45 Minuten (Wir: 30 Minuten)\n  - Publikum\n    - Vorkenntnisse etc.\n- Vortrag\n  - Klare Einteilung\n  - Details sind wichtig, aber nicht zu viel\n  1. Was ist das Thema\n  2. Thema 1\n  3. Thema 2\n  - $\\cdots$\n  9. Wor√ºber haben wir geredet\n  10.   Backup slides\n    - Wahrscheinliche Fragen  \n- Inhalt\n  - Was soll die Hauptaussage sein\n    - \"Warum sollte es die Zuschauer interessieren\"\n    - Zuh√∂rer vergessen den Gro√üteil\n      - **Filtern**\n    - Wichtige Konzepte **m√ºssen** erkl√§rt werden\n  - 15-20 Minuten Aufmerksamkeitsspanne\n    - Versuchen zu verl√§ngern\n      - Klarer Ablauf\n      - Abgrenzung in klare Sektionen\n      - Ansprechend Vortragen$_\\text{(Anekdoten, Witze)}$\n      - Viele Beispiele\n        - Bilder, Videos, live Demos, live Coding\n      - Fragen\n        - Rethorische Fragen\n    - Mitnehmen von verlorenen Zuh√∂rern$_\\text{(wo sind sie hin? üò≥)}$\n    - > Weniger ist mehr\n    - Zweck besserer Lesbarkeit sollten lange, komplizierte und mit Kommata in viele Teils√§tze aufgeteilte S√§tze vermieden werden.\n    - Design\n      - $\\LaTeX$\n      - Powerpoint\n      - [Impress.js](https://impress.js.org/#/bored) ([GitHub](https://github.com/impress/impress.js))\n      - Prezi\n      - > Kein Grafischer Schnick-Schnack\n      - Folie\n        - Titel\n        - (Untertitel)\n        - Name, RWTH etc.\n        - Event (Konferenz Name, Ort, Datum)\n        - Seitenzahl\n        - Negativbeispiel: ![Negativbeispiel](/assets/images/2022-05-13-17-54-40.png)\n- Vorbereitung\n  - Nicht am Handy sein\n  - Augenkontakt\n  - Vor**tragen** nicht lesen (Das zu erkennen ist trivial)\n  - Rechtzeitig beenden\n    - Zusammenfassen\n    - Abschlusssatz\n    - Danken\n    - Nach Fragen fragen\n    - Fr√ºhzeitig anfangen\n      - Zu nerv√∂s? Schlecht!\n      - Zu entspannt? Schlecht!\n    - √úben\n\n----------------\n### Wichtige Daten\n- Keine Ahnung (In der Klausurenphase :P)","n":0.048}}},{"i":4,"$":{"0":{"v":"Lineare Algebra","n":0.707},"1":{"v":"\n\n1. [[Vektorr√§ume|LA.vektorraeume]]\n2. [[Linearkombination|LA.linearkombi]]\n3. [[Lineare Unabh√§ngigkeit|LA.lineare_unabhaengikeit]]\n4. [[Basis eines Vektorraums|LA.basis]]\n","n":0.354}}},{"i":5,"$":{"0":{"v":"Vektorr√§ume","n":1},"1":{"v":"\n\n# Setup\n- $K$ K√∂rper: Z.B. $K = \\mathbb{R},\\mathbb{Q},\\mathbb{C},\\mathbb{F}_p,p \\in \\mathbb{R}, Z.B. \\mathbb{F}_2=\\{0,1\\}$\n- nach Definition: $V$ Vektorraum √ºber $K$\n\n# Definition\n## $K$-Vektorraum:\nBesteht aus\n- $V$ Menge\n- $V \\times V \\rightarrow V, (v,w) \\mapsto v+w$ Abbildung\n- $K \\times V \\rightarrow V, (a,w) \\mapsto av$ Abbildung\nso, dass die Vektorraumaxiome gelten.\n\n## Terminologien und Notationen:\n$$\n\\begin{aligned}\n    &a,b,c...&&\\qquad\\text{Skalare}&&\\qquad\\text{Element von $K$}\\\\\n    &u,v,w...&&\\qquad\\text{Vektoren}&&\\qquad\\text{Element von $V$}\\\\\n    &\\text{Nullvektor}&&\\qquad&&\\qquad\\text{$0$}\\\\\n    &\\text{f√ºr $v \\in V$:}&&\\qquad\\text{negativer Vektor zu $v$}&&\\qquad-v\\\\\n\\end{aligned}\n$$\n# VektorraumaxiomeAxiome\n$$\n\\begin{aligned}\n    &\\text{f√ºr $v,w,x \\in V$:}&&v+(w+x)=(v+w)+x&\\\\\n    &\\text{Es existiert $0 \\in V$ so, dass f√ºr $v \\in V$:}&&0+v=v+0=v&\\\\\n    &\\text{f√ºr $v \\in V$ existiert $w \\in V$:}&&w+v=v+w=0&\\\\\n    &\\text{f√ºr $v,w \\in V$:}&&v+w=w+v&\\\\\n    &\\text{f√ºr $a,b \\in K, v \\in V$:}&&a(bv)=(ab)v&\\\\\n    &\\text{f√ºr $v \\in V$:}&&1v=v&\\\\\n    &\\text{f√ºr $a,b \\in K, v \\in V$:}&&(a+b)v=(av)+(bv)&\\\\\n    &\\text{f√ºr $a \\in K, v,w \\in V$:}&&a(v+w)=(av)+(aw)&\\\\\n\\end{aligned}\n$$\n# Beispiel\n- $K$ wird $K$-Vektorraum mit\n  - Addition - K√∂rperaddition\n  - Skalarmultiplikation - K√∂rpermultiplikation\n- $m,n \\in \\mathbb{N};\\quad K^{m \\times n}$ wird $K$-Vektorraum mit\n  - Addition - Matrixaddition\n  - Skalarmultiplikation - Multiplikation einer Matrix mit einem Skalar\n- Spezialf√§lle\n  - $K^m \\coloneqq K^{m \\times 1}$ - Spaltenvektorraum: $\\small{\\{\\begin{pmatrix}a_1\\\\\\vdots\\\\a_m\\end{pmatrix}}\\vert a_i \\in K, 1 \\leq i \\leq m\\}$\n  - $K^{1 \\times n}$ - Zeilenvektorraum: $\\{(a_1,\\dots,a_n)\\vert a_i \\in K, 1 \\leq i \\leq n\\}$\n- $M$ Menge: $\\overbrace{\\text{Abb}(M,K)}^{K^M}$ wird $K$ Vektorraum mit:\n  - Addition - $f+g: M \\rightarrow K, (f+g)(m)\\coloneqq f(m)+g(m)$\n  - Skalarmultiplikation: $af: M \\rightarrow K, (af)(m) \\coloneqq af(m)$\n- $K[X]$ wird $K$-Vektorraum mit:\n  - Addition:$\\sum_{i=0}^na_i\\cdot X^i + \\sum_{i=0}^nb_i\\cdot X^i = \\sum_{i=0}^n(a_i+b_i)\\cdot X^i$\n  - Skalarmultiplikation: $a\\cdot(\\sum_{i=0}^na_i\\cdot X^i)=\\sum_{i=0}^n(a\\cdot a_i)\\cdot X^i$\n  - $K[X] = \\{\\sum_{i=0}^na_i\\cdot X^i\\vert a_i\\in K, 0\\leq i \\leq n, n\\in \\mathbb{N}_0\\}$: Polynomring\n\n# Lemma\n$$\na\\in K,v\\in V\\\\\nav=0\\Rightarrow a=0 \\vee v=0\\\\\n\\text{Beweis:}\\\\\n\\text{Sei }av=0,a\\neq 0, \\text{d.h. }a\\in K^x\\\\\n\\Rightarrow v = a^{-1}0=0\n$$\n# Korollar\n$a,b\\in K,v\\in V\\setminus\\{0\\}$\n$$\nav=bv\\Rightarrow a=b\\\\\nav=bv\\Rightarrow av-bv=0\\\\\n\\Rightarrow (a-b)v=0\\\\\n\\Rightarrow a-b=0\\\\\n\\Rightarrow a=b\\\\\n$$\n\n# Untervektorraum\n$U\\subseteq V$ hei√üt $K$-Untervektorraum von $V$, falls $U$ mit der Addition und der skalaren Multiplikation auf $V$ ein Vektorraum ist.\n","n":0.059}}},{"i":6,"$":{"0":{"v":"Linearkombination","n":1},"1":{"v":"\n# Definition\n$n \\in \\mathbb{N},(v_1,\\dotsc,v_n) n\\text{-Tupel in }V\\\\$\nEine Linearkombination von $(v_1,\\dotsc,v_n)$ ist ein $v\\in V$ der Form\n$$\nv = \\sum_{i=1}^na_iv_i\n$$\nmit $a_1,\\dotsc,a_n \\in K$ (Koeffizienten der Linearkombination)\n## Mit K√∂rpern\n$K$ K√∂rper, $V$ ein $K$-Vektorraum, $M \\subseteq V$\n- Linearkombination aus $M$:\n- Linearkombinationen von $(v_1, \\dotsc, v_n)$ mit $v_1,\\dotsc, v_n \\in M$\n\n# Beispiele\n- in $\\mathbb{Q}^{1\\times3}: \\quad(-1,-4,-1)\\in((1,2,1),(1,3,1))$\n\n# Bemerkung 1\n- $n \\in \\mathbb{N}, \\tau = (v_1,\\dotsc,v_n)$ Tupel in $V$\n- $\\lambda\\tau: K^n \\rightarrow V,\\begin{pmatrix}a_1\\\\\\vdots\\\\a_n\\end{pmatrix}\\mapsto \\sum^n_{i=1}a_iv_i$\n$$\n    \\left<v_1,\\dotsc, v_2\\right> = \\lambda\\tau(K^n) = \\text{Bild von }\\lambda\\tau\n$$\n\n# Bemerkung 2\n- $n \\in \\mathbb{N}, (v_1,\\dotsc,v_n)$ Tupel in $V$\n\n$$\n    \\left<v_1,\\dotsc, v_2\\right>\\leq V\n$$\n# Proposition\n$$\n    n \\in \\mathbb{N}\\text{Tupel in } V, v \\in V\\\\\n    \\text{Dann sind √§quivalent:}\\\\\n    \\begin{aligned}\n        &\\triangleright&&v \\in \\left<v_1,\\dotsc, v_2\\right>&\\\\\n        &\\triangleright&&\\left<v_1,\\dotsc, v_2,v\\right> \\subseteq \\left<v_1,\\dotsc, v_2\\right>&\\\\\n        &\\triangleright&&\\left<v_1,\\dotsc, v_2,v\\right> = \\left<v_1,\\dotsc, v_2\\right>&\\\\\n    \\end{aligned}\n$$\n# Korollar\n- $n \\in \\mathbb{N}, (v_1,\\dotsc,v_n)$ Tupel in $V$\n  - F√ºr $\\pi \\in S_n:$\n    - $\\left<v_1,\\dotsc, v_2\\right> = \\left<v_{\\pi(1)},\\dotsc, v_{\\pi(n)}\\right>$\n  - F√ºr $1\\neq k\\in\\underline{n}$ und $a \\in K$\n    - $\\left<v_1,\\dotsc, v_2\\right>=\\left<v_1+av_k,\\dotsc, v_2\\right>$\n  - F√ºr $a \\in K^\\times:$\n    - $\\left<v_1,\\dotsc, v_2\\right>=\\left<av_1,\\dotsc, v_2\\right>$\n\n# Erzeugendensystem:\n- Eine Menge hei√üt so, wenn sie den ganzen Vektorraum erzeugt\n\nTIME: -17:27\n","n":0.077}}},{"i":7,"$":{"0":{"v":"Lineare Unabh√§ngigkeit","n":0.707},"1":{"v":"- $v_1,\\dotsc v_n$ linear unabh√§ngig, d.h., $\\lambda_{(v_1,\\dotsc v_n)}$ injektiv\n- Aus $\\sum^n_{i=1}a_iv_i=\\sum^n_{i=1}b_iv_i$ folgt $a_i=b_i$ f√ºr alle $\\leq i \\leq n$.\n- Aus $\\sum^n_{i=1}a_iv_i = 0$ folgt $a_i=0$ f√ºr alle $\\leq i \\leq n$\n","n":0.18}}},{"i":8,"$":{"0":{"v":"Basis eines Vektorraumes","n":0.577},"1":{"v":"\n- $K$ K√∂rper, $V$ Vektorraum √ºber $K,M \\subseteq V$ Teilmenge\n- $M$ ist Erzeugendensystem (EZS) von $V \\Leftrightarrow \\left<M\\right>=V$\n- $M$ [[linear unabh√§ngig|LA.lineare_unabhaengikeit]] $\\Leftrightarrow$ Alle $v_1,\\dotsc v_n\\in M$ mit $n\\in \\N$ und $v_i$ paarweise verschieden sind linear unabh√§ngig.\n- Ein linear unabh√§ngiges EZS von $V$ nennt man Basis von $V$.\n  - Beispiel: $M=\\{,X,X^2,\\dotsc\\}$ ist eine Basis des $K$-[[Vektorraums|LA.vektorraeume]] $K[X]$.\n- Folgende Aussagen sind √§quivalent\n  1. $M$ ist Basis von $V$.\n  2. $M$ ist ein minimales EZS von $V$.<br/>D.h.: $M$ ist EZS und f√ºr alle $m\\in M$ ist $M\\setminus \\{m\\}$ kein EZS.\n  3. $M$ ist eine maximale linear unabh√§ngige Teilmenge von $V$.<br/>D.h.: $M$ ist linear unabh√§ngig und f√ºr alle $v \\in V\\setminus M$ ist $M\\cup\\{v\\}$ linear abh√§ngig.","n":0.094}}},{"i":9,"$":{"0":{"v":"Graphen","n":1}}},{"i":10,"$":{"0":{"v":"Formale Systeme, Automaten und Prozesse","n":0.447},"1":{"v":"\n# Formale Systeme, Automaten und Prozesse\n1. [[√úberblick|FOSAP.ueberblick]]\n2. [[Deterministische Endliche Automaten|FOSAP.DEA]]\n3. [[Endliche Automaten|FOSAP.EA]]\n4. [[Sprachen|FOSAP.sprache]]\n5. [[Nichtdeterministische Endliche Automaten|FOSAP.NFA]]\n6. [[FOSAP.regulSprachen]]\n   1. [[Algorithmen √ºber regul√§re Sprachen|FOSAP.regulSprachen.alg]]\n7. [[Kontextfreie Grammatiken|FOSAP.kontextfrei]]\n\n\n## Tutorium\n1. [[Erstes Tutorium|FOSAP.tut.1]]","n":0.192}}},{"i":11,"$":{"0":{"v":"tut","n":1}}},{"i":12,"$":{"0":{"v":"Erstes Tutorium","n":0.707},"1":{"v":"\n## 1)\n### a)\n$(KL)^*=(LK)^*\\\\$\n$K\\cup L=\\emptyset\\Rightarrow (KL)^*\\neq(LK)^*\\\\$\n- $K=\\{k\\},L=\\{l\\}$\n- $lk\\notin(KL)^*$\n- $kl\\notin(LK)^*$\n\n### b)\n- $K=\\{k\\}$\n- Sei $e\\in KK^*$\n  \n### c)\n- $(K\\cap L)^* \\subseteq K^*\\cap L^*$\n- Sei $w\\in K \\cap L,u\\in K|u\\notin L$\n  \n### d)\n- $K^*\\cap L^* \\subseteq (K\\cap L)^*$\n\n\n## 2)\n### a)\n\n### c)\n```mermaid\ngraph LR\nq1((q1))\nq2((q2))\nq3((q3))\nq4((q4))\nq5((END))\nq1-->|1|q2\nq2-->|2|q3\nq3-->|3|q5\nq5-->|1|q2\nq1-->|2,3|q4\nq2-->|1,3|q4\nq3-->|1,2|q4\nq4-->|1,2,3|q4\n```\n\n## 4)\n### a)\nAlle W√∂rter, deren L√§nge mod 4 1,2 betr√§gt\n### b)\n","n":0.144}}},{"i":13,"$":{"0":{"v":"√úberblick","n":1},"1":{"v":"\n# Formale Systeme und Modelle\n- Beschreibung von:\n  - Programmiersprachen\n  - Spezifikationen (UML)\n  - Daten und deren Beziehungen\n  - Netzwerken\n  - Modellierung von Rechnern und Berechnungen\n  - Komplexen Systemen\n\n## Zentrale Fragen\n- Wie kann man ein formales System spezifizieren? (Syntax)\n- Wie kann man den formalen Objekten eine klar definierte Bedeutung geben? (Semantik)\n- Wie kann man die Eigenschaften eines formalen Systems verstehen?\n- Wie kann man (auch algorithmisch) mit einem formalen System arbeiten?\n\n## Automaten\n- Endliche Automaten und Verallgemeinerungen von Kellerautomaten -> Turingmaschinen\n\n## Grammatiken\n- RegEx und kontextfreie Grammatiken\n\n## Nebenl√§ufige Systene\n- Petrinetze und Prozesskalk√ºle\n\n## Mathematische Methoden\n- exakte Definitionen\n- formale Beweise\n- Verwendung mathematischer Strukturen wie Graphen\n\n## Korrektheit\n- Grundlagen formaler Verifikationsmethoden\n\n## Automatisierung\n- formale Beschreibungen der Anforderungen\n","n":0.096}}},{"i":14,"$":{"0":{"v":"Sprachen","n":1},"1":{"v":"\n# Verkettung\n- $vw$ bezeichnet die Verkettung der W√∂rter $u,v,w\\in \\sum^*$\n\n## Definition 1.23\nSei $L\\subseteq \\sum^*$. Die Potenzen $L^n$, f√ºr $n\\in\\mathbb{N}$, sind induktiv wie folgt definiert.\n$$\n    L^0\\coloneqq \\{\\epsilon\\},\\\\\n    L^{n+1} \\coloneqq L^nL\n$$\nf√ºr alle $n\\in\\mathbb{N}$.\n## Definition 1.26\nDie Iteration (auch Kleene-Stern) einer Sprache $L$ ist die Sprache\n$$\n    L^* \\coloneqq \\bigcup_{n\\in\\mathbb{N}}L^n\n$$\n### Beobachtung\n1. $\\epsilon \\in L^0 \\subseteq L^*$\n2. Ein Wort $u \\neq \\epsilon$ liegt genau dann in $L^*$, wenn es ein $n\\geq1$ und W√∂rter $v_1,\\dotsc,v_n \\in L$ gibt.\n\n# Beispiele\n1. Nat√ºrliche zahlen $n\\in\\mathbb{N}$\n   - Alphabet: $\\sum=\\{0,\\dotsc,9\\}$ oder $\\sum=\\{\\mathbb{N}\\}$\n   - $\\{w\\in\\sum_a^*\\vert w\\text{ hat keine f√ºhrende }0\\}$\n     - $0001\\notin\\mathbb{N}$\n   - $v\\{0\\}$\n2. Alle m√∂glichen Stundenpl√§ne\n   - $\\sum=\\{\\#,\\}\\cup\\{'m','d','m','d','f'\\}$\n3. Sucher nach Abgabegruppen\n   - $(\\sum_{UTF_8})^*$\n   - $\\{w\\in \\sum_{UTF_8}^*\\vert \\text{als Infix \"Gr√º√üe\"}\\}\\cap L_{email}$\n\n## Beweise\n### Zeige oder widerlege\n- $(KL)M=K(LM),$\n  - $x\\in(KL)M.\\quad\\text{Sei }x=uvw, \\text{ mit }u\\in K,v\\in L,w\\in M\\\\\\text{Dann ist }x=(uv)w=uvw=u(vw)\\in K(LM), vw\\in LM,u\\in K$\n  - Analog, assozieativit√§t von Kompositionen, gilt genau\n- $L\\{\\epsilon\\}=\\{\\epsilon\\}L=L$\n  - $L\\{\\epsilon\\}\\subseteq\\{\\epsilon\\}: \\text{ Sei } w \\in L\\{\\epsilon\\}. w\\in L, \\text{ und damit }\\epsilon w\\in \\{\\epsilon\\}$\n","n":0.081}}},{"i":15,"$":{"0":{"v":"Regul√§re Sprachen","n":0.707},"1":{"v":"\nDer regul√§re Ausdruck $a(a+b)^*bb$ beschreibt die Sprache √ºber das Alphabet $\\sum=\\{a,b\\}$, in der alle W√∂rter mit a beginnen und auf 2 b enden.\n\n## Basisregeln\n- $\\emptyset\\in RA_{\\sum}$\n- $\\epsilon \\in RA_{\\sum}$\n- $a \\in RA_{\\sum}$ f√ºr alle $a\\in \\sum$\n\n## Rekursive Regeln\n- Wenn $r,s\\in RA_{\\sum}$, dann $(r+s)\\in RA_{\\sum}$\n- Wenn $r,s\\in RA_{\\sum}$, dann $(r\\cdot s)\\in RA_{\\sum}$\n- Wenn $r\\in RA_{\\sum}$, dann $r^*\\in RA_{\\sum}$\n\n![](/assets/images/2022-04-26-14-46-10.png)\n\n- Semantik\n  - ![](/assets/images/2022-04-26-14-52-39.png)\n\n## Pumping-Lemma\n- L ist regul√§r. Dann ist $n\\geq 1$, so dass f√ºr alle $w \\in L$ eine Zerlegung $w=xyz$ existiert, f√ºr die gilt.\n  1. $y\\neq \\epsilon$\n  2. $|xy|\\neq w$\n  3. $xy^kz\\in L$ f√ºr alle $k\\geq 0$\n\n## Myhill-Nerode-√Ñuivalenz\n- Sei $L\\subseteq\\sum^*$ eine Sprache. Wir definieren\n- Eine Sprache $L$ ist genau dann regul√§r, wenn index($L$)$<\\infty$\n","n":0.095}}},{"i":16,"$":{"0":{"v":"Algoritmen √ºber regul√§re Sprachen","n":0.5},"1":{"v":"\n# Minimierung von DFA\n- Effizientes Minimierungsverfahren f√ºr NFAs ist nicht bekannt\n\n## Notation\n- Mit $|A|$ bezeichnen wir die Anzahl der Zust√§nde eines endlichen Automaten $A$\n- Sei $L$ ein m√ºde","n":0.189}}},{"i":17,"$":{"0":{"v":"Kontextfreie Grammatiken","n":0.707},"1":{"v":"\n- F√ºr leeres Wort: $A\\rightarrow\\epsilon$\n- F√ºr jede Grammatik $G$ gibt es eine Grammatik $G'$ f√ºr die gilt: $L(G')=L(G)\\setminus L(\\epsilon)$\n- Erweiterungsschritt:\n  - Sind $A\\rightarrow \\epsilon$ und $B\\rightarrow \\alpha A\\beta$, so f√ºge die Regel $B\\rightarrow \\alpha\\beta$ hinzu\n\n# Chomsky-Normalform\nGilt wenn:\n- $A\\rightarrow BC$\n- $A\\rightarrow a$\n\nJede Kontextfreie Grammatik ist √§quivalent zu einer Kontextfreien Grammatik in Chomsky-Normalform\n## Umwandlung\n1. Elimination der $\\epsilon$-Regeln\n2. Terminalsymbole nur in Regeln der Form $A\\rightarrow A_1\\dotsc A_m$ mit $m>2$\n3. Elimination der Regeln $A\\rightarrow B$\n4. Elimination der Regeln $A\\rightarrow A_1 \\dotsc A_m$\n","n":0.113}}},{"i":18,"$":{"0":{"v":"Nichtdeterministische Endliche Automaten","n":0.577},"1":{"v":"\n- 5-Tupel (siehe [[DEA|FOSAP.DEA]])\n\n```mermaid\ngraph LR\nq0((q0))\nq1((q1))\nq2((q2))\nq3((q3))\nq4((q4))\nq5((q5))\nq0-->|epsilon|q1\nq2-->|epsilon|q1\nq1-->|a|q2\nq0-->|epsilon|q3\nq3-->|b|q4\nq4-->|a|q5\n```\n","n":0.447}}},{"i":19,"$":{"0":{"v":"Endliche Automaten","n":0.707}}},{"i":20,"$":{"0":{"v":"Deterministische Endliche Automaten","n":0.577},"1":{"v":"\n## Endliche Automaten\n- Berechnungsmodell zur Beschreibung sequentiller Prozesse\n- endliche Menge an Zust√§nden\n- Hat einen Startzustand und 1 oder mehr Endzust√§nde\n\n### Mustererkennung\n```mermaid\ngraph LR\nn((nichts)) -->|0|n((nichts))\nn((nichts)) -->|1|1((1))\n1((1))-->|0|n((nichts))\n1((1))-->|1|11((11))-->|1|11((11))\n11((11))-->|0|110((110))\n110((110))-->|0|n((nichts))\n110((110))-->|1|1101((1101))-->|0,1|1101((1101))\n```\n### Teilbarkeit durch 3\n```mermaid\ngraph LR\n0((0))\n1((1))\n2((2))\n0-->|1,4,7|1\n1-->|2,5,8|0\n1-->|1,4,7|2\n2-->|2,5,8|1\n2-->|1,4,7|0\n0-->|2,5,8|2\n0-->|0,3,6,9|0\n1-->|0,3,6,9|1\n2-->|0,3,6,9|2\n```\n## Alphabet\n- Nicht leere Menge\n  - behinhaltet Symbole,Buchstaben oder Zeichen\n- Ein Wort ist eine endliche Folge von Zeichen aus dem Alphabet\n\n### Notation\n- $\\sum$,$\\Gamma$ und Varianten wie $\\sum_1$, $\\Gamma'$\n- $a,b,c,\\dotsc$ und Varianten stehen f√ºr Zeichen\n\n### Beispiele\n1. Boolsche Alphabet $\\{0,1\\}$\n2. Morsealphabet $\\{.,-,\\quad\\}$\n\n## W√∂rter\n### Notation\n- Ohne Klammern und Kommata\n- $u,v,w,\\dotsc$ und Varianten stehen f√ºr W√∂rter\n\n## Sprache\n- Menge von W√∂rtern\n\n# DEA\n- 5-Tupel $(Q,\\sum,\\delta,q_0,F)$\n  - $Q$: Menge der Zust√§nde\n  - $\\sum$: Eingabealphabet\n  - $\\delta: Q \\times \\sum \\rightarrow Q$: Abbildung: die Transitionsfunktionen\n  - $q_0 \\in Q$: Der Anfangszustand\n  - $F \\subseteq Q$: Die Menge der Endzust√§nde\n\n## DEA: ist die bin√§re Zahlenfolge durch 3 teilbar\n```mermaid\ngraph LR\n0((0))\n1((1))\n2((2))\n0-->|0|0\n0-->|1|1\n1-->|1|0\n1-->|0|2\n2-->|0|1\n2-->|1|2\n```\n### Beweis\nF√ºr $w \\in {0,1}*$ sei $b(w) \\in \\mathbb{N}$ der Wert von $w$ als Bin√§rzahl.\n#### Lemma\nSeien $w\\in \\{0,1\\}*$ und $a\\in \\{0,1\\}$. Dann gilt\n$$\n  b(wa) = 2 \\cdot b(w) + a\n$$\n##### Beweis\nSei $w=a_1,\\dotsc, a_n$. Dann ist\n$$\n  b(wa) = \\sum_{i=1}^n a_i2^{n+1-i}\n$$\n\n# Satz 1.29\nSei $L\\subseteq\\sum^*$ DFA-Erkennbar. Dann ist auch $\\overline{L}$ DFA-Erkennbar.\n- Wenn zwei Sprachen DFA-erkennbar sind, dann ist auch der Durchschnitt DFA-erkennbar.\n\n","n":0.074}}},{"i":21,"$":{"0":{"v":"Datenstrukturen und Algorithmen","n":0.577},"1":{"v":"\n1. [[√úberblick|DSAL.ueberblick]]\n2. Datenstrukturen\n   1. [[DSAL.abstraktedatenstrukturen]]\n   2. [[DSAL.linearedatenstrukturen]]\n   3. [[B√§ume|DSAL.baeume]]\n      1. [[Rot-Schwarz-B√§ume|DSAL.baeume.rsbaum]]\n      2. [[B-B√§ume|DSAL.baeume.bbaum]]\n   4. [[Priorit√§tsschlangen|DSAL.prioschlange]]\n   5. [[Graphen|DSAL.graphvonf]]\n   6. [[Union-Find-Strukturen|DSAL.Unionfind]]\n   7. [[Graphen]]\n3. Algorithmen\n   1. [[Analyse|DSAL.analyseVonAlgorithmen]]\n","n":0.204}}},{"i":22,"$":{"0":{"v":"√úberblick","n":1},"1":{"v":"\n- Software = Datenstrukturen + Algorithmen\n- Schrittweise Modifikation von Daten zur L√∂sung von Problemen\n- Eigenschaften (nach Donald Knuth)\n  - Determinismus\n  - Input ($\\# \\geq 0$)\n  - output ($\\# \\geq 0$)\n  - Terminierung\n\n# Analyse\n- partielle Korrektheit\n- totale Korrektheit\n- Komplexit√§t\n  - Speicherplatz\n  - Rechenzeit\n- Robustheit\n  - bei korrekter Eingabe\n\n# Komplexit√§t\n- Effizienz (Praxistauglichkeit)\n- worst/best/average case\n- Wie viel l√§nger dauert die Berechnung, wenn der Input verdoppelt wird\n- Gibt es einen besseren Algorithmus (Problem-Reduktion)\n\n# Effizienz\n- Problem $\\rightarrow$ Ressourcen\n- Ressourcen $\\rightarrow$ Problem\n- Ressourcen-Typen\n  - Rechenzeit\n  - Speicherplatz\n  - Energieverbrauch\n  - ...\n","n":0.108}}},{"i":23,"$":{"0":{"v":"Priorit√§tsschlangen","n":1},"1":{"v":"\n- Warteschlange mit \"Vordr√§ngeln\"\n- Einf√ºgen am Ende der Schlange\n- Jedes Element hat eine Priorit√§t und wird, nach dieser sortiert, zur√ºckgegeben\n- Aufwand steigt proportional zur Priorit√§t\n- Liste wird vollst√§ndig sortiert, obwohl nur das maximale Element gefunden werden muss\n- Reihenfolge nicht vorhersehbar\n- Durch implementierung als Baum\n  - Nur entlang der Pfade sortiert\n  - Implementierung als Array\n- ","n":0.136}}},{"i":24,"$":{"0":{"v":"Lineare Datenstrukturen","n":0.707},"1":{"v":"\n- Sequenz $\\{x_1,\\dotsc,x_n\\}$\n\n## Listen\n- $L = \\{x_1,\\dotsc,x_n\\}$\n- Zugriff auf beliebige Elemente $x_i$\n  - Per Index\n    - `Get(i)`\n  - Per Marker\n    - `GetFirst()`\n    - `GetNext()`\n    - `GetPrevious()`\n- Random Access\n  - Implementierung durch Arrays\n  - `Get(i) = L[i]`\n  - Nachteile\n    - Elemente L√∂schen erzeugt L√ºcken, oder alle h√∂heren Elemnte m√ºssen verschoben werden\n    - statische Obergrenze f√ºr Listenl√§nge\n- Sequential Access\n  - Implementierung durch Pointer oder Container\n  - Marker zeigt auf aktuelle Position\n  - Nachteil:\n    - Elementzugriff erfordert lineare Suche\n  - Beliebiges Erweitern oder L√∂schen\n\n### Stack\n- Nur einf√ºgen am Anfang\n- Auslesen auch nur am Anfang\n- Last in, First out\n\n# Suche im Labyrinth\n- Annahme: Array hat keine Zykel\n- Pfad = Liste\n\n# Baum\n- Jeder Knoten ist Wurzelknoten eines Teilbaumes\n- Tiefe: Anzahl der Kanten von Wurzel bis Knoten\n- Grad: Anzahl der Nachfolger\n- Bl√§tter: Knoten ohne Nachfolger\n","n":0.088}}},{"i":25,"$":{"0":{"v":"Graphen","n":1},"1":{"v":"\n- Kanten k√∂nnen gerichtet (Vorg√§nger/Nachfolger) oder ungerichtet (Nachbarschaft) definiert werden\n- Zusammenh√§ngend (stark/schwach)\n  - f√ºr jedes Paar Knoten $v_i,v_j$ existiert ein Pfad von Kanten von $v_i \\rightarrow v_j$ und $v_j \\rightarrow v_i$.\n- Vollst√§ndig\n  - zwischen je zwei Kindern existiert eine Kante\n  - $m\\cdot (n-1)/2$\n- Isomorph\n  - Graphen sind isomorph, wenn beide durch umnummerierung in einander √ºberf√ºhrt werden k√∂nnen\n- Planare Graphen\n  - Keine √úberschneidungen der Kanten\n\n\n# Representation\n- Allgemeine Graphen\n  - Adjazenzmatrix\n  - > Das Internet als Adjazenzmatrix darzustellen, w√§re nicht so schlau (...) wenn sie das dann beim durch gehen ein paar milliarden mal machen m√ºssen, dann nervt das schon\n  - Adjazenzliste\n- Planare Graphen\n- Simplex-Strukturen","n":0.099}}},{"i":26,"$":{"0":{"v":"B√§ume","n":1},"1":{"v":"\n<img src=\"https://c.tenor.com/W8pYfpTSrYIAAAAS/roomba-cat.gif\" alt=\"cat\" id=cat>\n\n\n- Hierarische Datenstrukturen\n  - Zusammenfassung von Gruppen\n  - Eindeutige Schachtelung\n\n# Implementation\n```py\nclass Node:\n    def __init__(self,value):\n        self.value = value\n        self.right = None\n        self.left = None\n```\n## Array\n- Vollst√§ndige B√§ume\n- $N(k)$ = Anzahl der Knoten der Tiefe $k$\n- $N(k) = 2\\times N(k-1) \\rightarrow N(k)=2^k$\n- Speichere die Knoten der Tiefe $k$ in den Array-Eintr√§gen $A[2^k\\dotsc2^{k+1}-1]$\n- Jeder Knoten `A[i]` findet seinen Nachfolger in `A[2i]` und `A[2+1]`\n\n```py\ndef ReadTerm():\n    L = ReadProduct()\n    op = getChar()\n    while op = '+' or op = '-':\n        R = ReadProduct()\n        L = Node(L,op,R)\n        op = getChar()\n    return L\n```\n# Effizienz\n- Balancierte B√§ume\n  - $N_{bal, max}(h) = 2^{h+1}-1$\n  - $N_{bal, min}(h) = 1+N_{bal,min}(h-1)+N_{bal,min}(h-2)$\n\n# Suchen\n```py\ndef Search(X,T):\n    if X == Value(T):\n        return True\n    elif Leaf(T):\n        return False\n    elif X < Value(T):\n        return Search(X,Left(T))\n    else:\n        return Search(X,Right(T))\n```\n\n\n\n<script defer>\n\n    const cat = document.getElementById(\"cat\");\n    const anz = Number(location.hash.substring(1))!=NaN?Number(location.hash.substring(1)):4;\n    const n = Math.floor(cat.parentElement.offsetWidth/cat.width)*4==Infinity?0:Math.floor(cat.parentElement.offsetWidth/cat.width)*anz;\n    for(let i = 0; i < n; i++)\n        cat.parentElement.append(cat.cloneNode());\n    cat.remove();\n\n</script>\n","n":0.083}}},{"i":27,"$":{"0":{"v":"Rot-Schwarz-B√§ume","n":1}}},{"i":28,"$":{"0":{"v":"bbaum","n":1},"1":{"v":"\n- Alle Bl√§tter haben die selbe Tiefe","n":0.378}}},{"i":29,"$":{"0":{"v":"Analyse von Algorithmen","n":0.577},"1":{"v":"\n- Effizienz\n  - Gute Nutzung von Ressourcen\n  - Komplexit√§t von Algorithmen\n- Ressourcen\n  - Rechenzeit\n  - Speicherplatz\n  - Energie\n- Aufwand / Komplexit√§t\n  - Tats√§chlicher Verbrauch von Ressourcen\n- Performance Charts\n  - X: Gr√∂√üe der Eingabedaten\n  - Y: Ben√∂tigte Rechenzeit\n\n```\nY\n^\n|   //  \n|  //  /\n| /|  /\n|/|  /\n| | /                      \n|| /          _____________---------------\n||/-----------\n+----------------------------------------->X\n```\n- Abstrakte Analyse\n  - Anzahl der wesentlichen Operationen auf einem idelaisierten Computer\n  - Unabh√§ngig von der Programmiersprache\n\n## Stripped Python\n- Teilmenge von Python\n  - Prozedur Aufrufe\n  - Integer-Arithmetik\n  - Zuweisungen (Lesen / Schreiben)\n  - if-then-else\n  - while\n- Vollst√§ndig, aber einfacher zu analysieren als Python\n- Berechnungsaufwand\n  - Prozedur-Aufruf\n    - Speichere Kontext\n    - Speichere R√ºcksprungadresse\n    - Kopiere Parameter\n    - Generiere neuen Kontext\n    - $\\dotsc$\n    - Kopiere R√ºckgabewert\n    - Stelle alten Kontext wieder her\n  - Kosten $C_{PC}$\n  - if-then-else\n    - `if X then Y else Z`\n      - worst case:\n        - OP = OP(X) + max{OP(Y),OP(Z)}\n      - Average\n        - P = Prob(X=True)\n        - OP = OP(X) + p * OP(Y) + (1-P) OP(Z)\n  - Kombinatorik\n    - Permutationen: $n!$\n    - Kombinationen: $\\binom{n}{k}=\\frac{n!}{k!(n-k)!}$\n    - Summe der Kombinationen:$\\sum_{k=0}^n\\binom{n}{k}=2^n$\n\n--------------------------------------------------------------------------\n\n- Definitionen von Schranken f√ºr Funktionen\n\n![](/assets/images/2022-04-21-12-00-18.png)\n\n--------------------------------------------------------------------------\n## Fibonacci\n$$\n\\begin{aligned}\n  F(n)&=F(n-1)+F(n-2)\\\\\n  &>2\\times F(n-2)\\\\\n  &>4\\times F(n-2)\\\\\n  &>\\dotsc\\\\\n  &>2^{n}\\times F(n-2)\n\\end{aligned}\n$$\n--------------------------------------------------------------------------\n$$\n\\begin{aligned}\n  &O(1) &-&\\text{Elementaroperation}\\\\\n  &O(\\log n) &-&\\text{Bin√§re Suche}\\\\\n  &O(n) &-&\\text{Lineare Suche}\\\\\n  &O(n\\times \\log n) &-&\\text{Sortieren (sp√§ter)}\\\\\n  &O(n^2) &-&\\text{Sortieren (neulich)}\\\\\n  &O(n^3) &-&\\text{Invertieren von Matrizen}\\\\\n  &O(2^n) &-&\\text{Labyrinth-Suche (Vollst√§ndig)}\\\\\n  &O(n!) &-&\\text{Permutationen}\\\\\n\\end{aligned}\n$$\n--------------------------------------------------------------------------\n- Beweis durch vollst√§ndige Induktion\n\n## Rekursionsgleichung\n- Elimination\n  - Einsetzen\n  - Summenformel\n- Master-Theorem\n  - ![](/assets/images/2022-04-26-11-48-06.png)\n- Direkter Ansatz\n  - ","n":0.067}}},{"i":30,"$":{"0":{"v":"Abstrakte Datenstrukturen","n":0.707},"1":{"v":"\n- Keine Festlegung der Implementierung\n- Axiome beschreiben statische Beziehungen\n- Beispiele\n  - Aufz√§hlungstypen (`bool`, `enum`)\n  - Skalare Typen (`char`, `int`, `float`, ...)\n    - Eindimensionaler Wertebereich\n    - In Praxis meist endlich \n  - Zusammengesetzte Typen (`struct`, `class`)\n  - Lineare Strukturen (`list`, `queue`, `stack`)\n  - B√§ume\n  - Graphen\n- endlicher Wertebereich\n  - vollst√§ndig durch Tabellen spezifizierbar\n- Verallgemeinerung\n  - Aufz√§hlungstypen: `enum`\n  - z.B. Wochentage, chemische Elemente\n  - Kodierung (oft) als ganze Zahl Modulo n (implizite Ordnungsrelation)\n\n## Nat√ºrliche Zahlen\n\n```py\ndef ZERO():\n    return []\n\ndef SUCC(x):\n    return x + [1]\n\ndef PRED(x):\n    return x[1:]\n\ndef VALUE(x):\n    return len(x)\n\ndef ADD(x, y):\n    if x == ZERO():\n        return y\n    return SUCC(ADD(PRED(X),y))\n\ndef MUL(x, y):\n    if x == ZERO():\n        return ZERO()\n    return ADD(MUL(PRED(x), y), y)\n```\n","n":0.096}}},{"i":31,"$":{"0":{"v":"Union-Find-Strukturen","n":1}}},{"i":32,"$":{"0":{"v":"Betriebssysteme und Systemsoftware","n":0.577},"1":{"v":"\n1. [[BUS.OS_aufbau_und_aufgaben]]\n2. [[Linux-Shell|BUS.linux-shell-bash]]\n3. [[C-Programmierung|BUS.C]]\n4. [[Kernel|BUS.kernel]]\n5. [[Prozesse, Threads und Systemkommunikation|BUS.PTScom]]\n6. [[Prozessynchronisation|BUS.Prozessynchronisation]]\n7. [[Speicherverwaltung|BUS.speicherverwaltung]]\n8. [[Dateisysteme|BUS.Dateisysteme]]","n":0.289}}},{"i":33,"$":{"0":{"v":"Speicherverwaltung","n":1},"1":{"v":"\n# Swapping\n- Swap-files\n\n# Probleme\n- Arbeitsspeicher kleiner als ben√∂tigter Adressraum\n- Ben√∂tigter Arbeitsspeicher aller Prozesse\n\n## Fr√ºhe L√∂sung: Overlays\n- Es gibt Teile eines Programmes, die nie gleichzeitig im Hauptspeicher ben√∂tigt werden\n\n## virtueller Speicher\n- Virtuell mehr Speicher bereit als vorhanden\n\n# Segmentierung\n- Prozess hat logischen Adressraum: Sammlung von Segmenten\n  - Unterprogramm\n  - Programmdaten\n  - Variablen\n  - Stack\n- Besitzt einen Namen und eine L√§nge\n- Logische Adresse: $\\text{Segmentnummer}+\\text{offset}$\n\n# Adressierung\n- Logische (Virtuelle Adressen)\n  - `0x00000000 - 0xC0000000`\n  - ","n":0.12}}},{"i":34,"$":{"0":{"v":"Linux-shell Bash","n":0.707},"1":{"v":"\n```bash\n# get documentation\nman\n# Remove everything\nrm -r *\n# print\necho hello, world!\n# print folder\nls .\n# change directory\ncd\n# print date\ndate\n# word count\nwc\n# print current path\npwd\n# pipe\n# word count of current path\npwd | wc\n```\n> Hust hust hust hust; dass k√∂nnen wir schreiben, in eine neue Zeile\n","n":0.154}}},{"i":35,"$":{"0":{"v":"kernel","n":1}}},{"i":36,"$":{"0":{"v":"Atomare Operationen","n":0.707},"1":{"v":"\n- [Intel](https://cdrdv2.intel.com/v1/dl/getContent/671447)\n- [AMD](https://www.amd.com/system/files/TechDocs/40332.pdf)\n\n# Test-and-set: TSL instruction\n## Implementierung des Betretens und Verlassen eines kritischen Bereichs\n### C\n```c\nbool test_and_set(bool* target)\n{\n    bool res = *target;\n    *target = true;\n    return res;\n}\n```\n### Assembler\n```asm\nenter_region:\n    tsl register, lock\n    cmp register, #0\n    jnz enter_region\n\n    ret\n\nleave_region:\n    mov lock, #0\n    ret\n```\n# Swap\n### C\n```c\nkey = true;\nwhile(key==true)\n{\n    swap(&lock, &key);\n}\n/* Kritischer Bereich */\nlock = false;\n```\n### Assembler\n```asm\nenter_region:\n    mov register, #1\n    xchg register, lock\n    cmp register, #0\n    jne enter_region\n\n    ret\n\nleave_region:\n    mov lock, #0\n    ret\n```\n# Wait und signal\n### c\n```c\ns = 1;\nwhile(s)\n{\n    while(s==0)\n    {\n        __asm(\"nop\");\n    }\n    s=s-1;\n}\n\nvoid signal()\n{\n    s = s + 1;\n}\n```\n### Assembler\n```asm\nmutex_lock:\n    tsl register, mutex\n    cmp register, #0\n    jze ok\n    call thread_yield\n    jmp mutex_lock\nok:\n    ret\n\nleave_region:\n    mov mutex, #0\n```\n","n":0.099}}},{"i":37,"$":{"0":{"v":"Prozessynchronisation","n":1},"1":{"v":"\n1. [[Atomare Operationen|BUS.atomOp]]\n\n# Motivation und einfache L√∂sungsversuche\n- Es darf auf geteilten Speicher nie gleichzeitig geschrieben und gelesen werden, um Inkonsistenzen zu vermeiden.\n- \n\n# Semaphore\n- Integer-Variable $s$ mit 3 atomaren Operationen\n  - init($s$, anfangswert)\n  - wait($s$)\n  - signal($s$)\n- Wechselseitiger Ausschluss: *Mutex* = Semaphor mit anfangswert $1$\n- Mehrere Prozesse im kritischen Bereich erlaubt: *Z√§hlsemaphor* mit Anfangswert $n$\n- Zeitliche Ablaufsteuerung:\n  - Initialisierung\n    - init(sync, 0)\n  - Prozess A\n    - Operationend\n  - Prozess B\n\n# Erweiterte Konstrukte","n":0.118}}},{"i":38,"$":{"0":{"v":"Prozesse, Threads und Systemkommunikation","n":0.5},"1":{"v":"# Prozessverwaltung\n\n# Threads\n- user-threads\n  - thread-management im programm, nicht im Betriebssystem\n  - Kernel sieht nur den Prozess\n  - Wenn ein Thread h√§ngen bleibt, bleiben alle h√§ngen\n- Kernel-Thread\n  - Management durch Kernel\n  - Blockiert ein Thread, weist der Kernel die Cpu weiter zu\n  - Multicore-CPUs k√∂nnen genutzt werden\n  - Wechsel zwischen Threads so aufwendig wie von Prozessen\n\nBluetoos -> Bluetoof -> bluetooth\n# Scheduling\n\n- Mehrere Prozesse m√ºssen gleichzeitig ausgef√ºhrt werden\n  - Prozess muss geladen werden\n  - CPU-Zeit muss zugeteilt werden\n\n## Strategien\n- Long-Term_scheduler\n  - Entscheidet welche Prozesse zur ready-queue hinzugef√ºgt werden\n- Welche Prozesse sollen bedient werden?\n  - Fairness: Kein Prozess soll zu lange warten\n  - Wichtigkeit: Prozesse mit hoher Priorit√§t sollen bevorzugt werden.\n- Round Robin\n- ","n":0.095}}},{"i":39,"$":{"0":{"v":"Betriebssysteme: Aufbau und Aufgaben","n":0.5},"1":{"v":"\n## Einteilung des Computers in vier Bereiche\n1. Computer Hardware: Ansammlung von Betriebsmitteln, welche die Ausf√ºhrung von Programmen erm√∂glichen\n2. Betriebssystem: Verwaltung und Koordination der Hardware\n3. System- und Anwendungsprogramme\n4. Benutzer: Menschen oder andere Computer\n\n## Computer-Hardware\n- Systembus verbindet alle Ger√§te des Computers\n   - Eine oder mehrere CPUs\n   - Gemeinsamer Speicher f√ºr Aufgaben der CPU und anderer Ger√§te\n   - Controller zum Anschluss von I/O-Ger√§ten\n- von-Neumann: Prominente Rechnerarchitektur\n\n```mermaid\ngraph TD\nCPU[CPU]-->Systembus\nFestplatten[Festplatten]-->Fest[Festplatten Controller]-->Systembus\nDrucker[Drucker]-->usb[USB Controller]\nMaus[Maus]-->usb[USB Controller]\nTastatur[Tastatur]-->usb[USB Controller]\nExterne[Externe Laufwerke]-->usb[USB Controller]\nusb[USB Controller]-->Systembus\nMonitor[Monitor]-->Grafikkarte\nGrafikkarte[Grafikkarte]-->Systembus\nSystembus-->Hauptspeicher\n```\n## CPU\n- Verf√ºgt √ºber Register zur Ausf√ºhren von Operationen\n  - Datenregister, Adressregister, Spezialregister\n- Zus√§tzlich: Caches\n  - Schneller Pufferspeicher\n  - Schnellerer Zugriff auf Caches als als auf Hauptspeicher\n  - Je kleiner, desto schneller\n  - Caches sind transparent f√ºr das Betriebssystem\n\n### Pipelining\n-  Das Ausf√ºhren der einer Instruktion l√§sst sich in Unterinstruktionen aufteilen\n   -  Fetch->Decode-Execute\n- Dadurch l√§sst sich Instruktionsparallelismus implementieren\n- Vorteil\n  - H√∂herer Durchsatz\n- Nachteil\n  - Teilweise h√∂here Latenz\n\n### Superskalare Ausf√ºhrung\n- Wenn mehr Ausf√ºhrungseinheiten existieren, k√∂nnen mehrere Instruktionen parallel ausgef√ºhrt werden\n\n## Zusammenspiel der Komponenten\n- CPU f√ºhrt Operationen aus\n- CPU und I/O-Ger√§te werden nebenl√§ufig ausgef√ºhrt\n  - Jeder Controller ist f√ºr einen bestimmten Ger√§tetyp verantwortlich\n  - Zur Ausf√ºhrung einer Operation eines Ger√§tes wird die CPU gebraucht\n    - Jeder Controller hat eigene Register und einen lokalen Buffer\n    - Die CPU verschiebt Daten zwischen Hauptspeicher und Caches\n    - Nach verschieben der Daten wird die Operation gestartet\n  - Heute: DMA - Direct Memory Access\n    - Separater Controller zum verschieben von Daten zwischen CPU und Ger√§ten\n    - Entlastung der CPU\n\n# Betriebssystem:\n- Ansammlung von Programmen zur effizienten und komfortablen Nutzung\n  - Plattform zur Ausf√ºhrung von Programmen\n  - Effiziente Aufteilung der _Betriebsmittel_ (CPU, Festplatten, ...) auf mehrere Benutzer bzw. Benutzerprogramme\n- Betriebsmittel:\n  - Prozessoren, Prozesse, Threads\n  - Speicher\n    - Hauptspeicher, Caches, virtueller Speicher\n  - Dateisystem\n    - Verzeichnisse, Dateien\n  - I/O-Ger√§te\n    - Grafikkarte, Netzwerkkarte, Festplatte, Tastatur, Maus\n  - Klassifikation\n    - Exklusive oder geteilte Nutzung?\n    - Entziehbar oder nicht entziehbar?\n    - \n","n":0.058}}},{"i":40,"$":{"0":{"v":"Dateisysteme","n":1},"1":{"v":"\n- Datei: Folge zusammengeh√∂riger Daten\n- Jede Datei braucht eine Struktur\n  - Dateiname\n  - Identifikator\n  - Dateityp\n  - Attribute\n    - Zugriffsrechte\n    - Benutzeridentit√§ten\n    - Datum/Uhrzeit der Erstellung/√Ñnderung\n    - Gr√∂√üe\n- Dateiverwaltung\n  - Verwaltung der ge√∂ffneten Dateien\n  - Abbildung der logischen Bytepositionen in der Datei auf physikalische Blocknummern im Hintergrundspeicher\n  - Speicherverwaltung\n  - Ermittlung der Ger√§teadressen\n  - Scheduling von Zugriffen auf die Dateien\n  - File Descriptor\n    - Erzeugt eine neue Verwaltungsstruktur um die Datei zu verwalten\n  - Jeder Prozess hat eine eigene Tabelle f√ºr FDs\n\n```mermaid\ngraph TD\nProzess-->|open| Kernel -->Hintergrundspeicher-->f[File control block]\nHintergrundspeicher -->Verzeichnisstruktur\n```\n\n```c\nopen(fn, r)\nclose(fd)\nread(fd, buf, n)\n```","n":0.105}}},{"i":41,"$":{"0":{"v":"C-Programmierung","n":1},"1":{"v":"\n## main\n```c\n#include <stdint.h>\nint main(int32_t argc, char** argv)\n{\n    printf(\"Number of arguments: %d\\n\",argc);\n    for(int i = 0; i < argc; i++)\n    {\n        printf(\"Parameter %d: %s\\n\",i,argv[i]);\n    }\n    return 0;\n}\n```\n- Pass-by-value\n- > Huch fehlgeschlagen\n```c\n    !!convert_int_to_bool\n    struct test x;\n    (*x).y == x->y\n```","n":0.164}}}]}
